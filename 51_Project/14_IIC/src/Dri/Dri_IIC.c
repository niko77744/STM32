#include "Dri_IIC.h"

// 起始信号：当SCL处于高电平时，SDA由高变低。
void Dri_IIC_Start() {
    SDA = 1;  // SDA由1变0
    SCL = 1;  // 主设备拉高时钟线

    // 拉低数据线
    SDA = 0;

    // 拉回时钟线，方便下一次拉高时钟线，而不需要等待时钟下拉上拉，解决同步问题
    SCL = 0;
}

// 发送结束信号  当SCL处于高电平时，SDA由低变高
void Dri_IIC_Stop() {
    SDA = 0;
    SCL = 1;
    SDA = 1;
}

// 单片机向从设备发送数据，所以需要一个形参
/**
 * @brief 发送一个字节数据
 * @param byte 要发送的单字节数据
 */
void Dri_IIC_SendByte(u8 byte) {
    // 注意：SDA是一位一位的，不能给SDA直接赋值
    /* &1不变   &0得0  这样可以取地一个字节的每一个位的值来给数据线SDA
    取最高位：(byte & 10000000) == 0 ? 0 : 1
    取次高位：(byte & 01000000) == 0 ? 0 : 1
    次次高位：(byte & 00100000) == 0 ? 0 : 1
    ...
    取最低位：(byte & 00000001) == 0 ? 0 : 1
    */
    u8 i;
    for (i = 0; i < 8; i++)
    {
        // 与1或0不变
        // 先取高位 判断与出来是0 那么 该位就是0
        SDA = (byte & (0x80 >> i)) == 0 ? 0 : 1;  //完成对SDA的位赋值 通过判断是0? 1:0 来确认该位是不是0，否则是1 注意优先级
        SCL = 1;
        SCL = 0;
    }
}

// 因为是接收从设备的一个字节，所以不需要参数，返回出去可以使用
/**
 * @brief 接收一个字节的数据
 * @return u8 返回接收到的数据
*/
u8 Dri_IIC_ReceiveByte() {
    /*
    假设接收(SDA是一位一位的) 11001011

    byte: 0000 0000  用来保存接收的数据      或0不变，用作为保证最后一位都是0
    第一次：   0000 0000 | 1(SDA最高位)   	  byte变为00000001  然后左移1位
    第二次：   0000 0010 | 1(SDA次高位)   	  byte变为00000011  然后左移1位
    第三次：   0000 0110 | 0(SDA次次高位)  	 byte变为00000110  然后左移1位
    第四次：   0000 1100 | 0   				byte变为00001100  然后左移1位
    第五次：   0001 1000 | 1   				byte变为00011001  然后左移1位
    ...
    原理类似于移位寄存器
    */
    u8 i;
    u8 bytes = 0x00;

    // 释放数据线（串行），方式是让单片机与数据总线断开  主设备释放SDA以允许从设备驱动SDA
    // 相当于开漏模式，SDA=1相当于单片机与SDA断开连接，由上拉电阻维持高电平
    SDA = 1;

    // 逐比特获取数据
    for (i = 0; i < 8; i++)
    {
        //  byte 接收到了SDA的数据，并放在了最低位，其他左移1位
        bytes = (bytes << 1) | SDA;
        SCL = 1;
        SCL = 0;
    }
    return bytes;
}


// 需要一个形参来确认信号
/**
 * @brief 发送一个应答信号（1比特数据）
 * @param bit ack 要发送的1bit数据
 */
void Dri_IIC_SendAck(bit ack) {   //0表示成功，可以继续。 1表示失败或不需要
    SDA = ack;  //先准备好数据，再拉高时钟线
    SCL = 1;   //拉高时钟线，完成SDA的采集信号，然后拉低时钟线
    SCL = 0;
}


// 因为是接收从设备的信号，所以不需要参数，返回ack可以做判断
/**
 * @brief 接收应答信号
 * @return bit 返回接收到的信号
*/
bit Dri_IIC_ReceiveAck() {
    bit ack;  //0表示成功，可以继续。 1表示失败或不需要

    // 单片机释放数据线（串行），方式是让单片机与数据总线断开  主设备释放SDA以允许从设备驱动SDA
    // 相当于开漏模式，SDA=1相当于单片机与SDA断开连接，由上拉电阻维持高电平
    SDA = 1;

    // 时钟信号是高电平的时候，接受数据线的数据
    SCL = 1;
    ack = SDA;  //因为ack是1位的，可以直接用SDA赋值
    SCL = 0;

    return ack;
}
